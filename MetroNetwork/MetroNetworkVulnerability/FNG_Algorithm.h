#pragma once
#ifndef FNG_ALGORITHM_H
#define FNG_ALGORITHM_H
#include "Node.h"
#include "Algorithm.h"
#include <iostream>
#include <vector>
using namespace std;
class FNG_Algorithm :public Algorithm{
private:
	NODE findFirstNode(vector<NODE>& noSelectNode){
		double maxb = 0;
		size_t num = 0;
		for (size_t i = 0; i < noSelectNode.size(); i++){
			if (maxb<noSelectNode[i].vulnerability() || maxb == 0){
				num = i;
				maxb = noSelectNode[i].vulnerability();
			}
		}
		NODE nde = noSelectNode[num];
		noSelectNode.erase(noSelectNode.begin() + num);
		return nde;
	}
	vector<NODE> findNeighbor(vector<NODE> aNode, vector<NODE> noSelectNode, vector<vector<double>> world){
		vector<NODE>neighbor;
		for (size_t i = 0; i < aNode.size(); ++i){
			for (size_t j = 0; j < noSelectNode.size(); ++j)
			if (world[aNode[i].number() - 1][noSelectNode[j].number() - 1]>0){
				size_t z = 0;
				for (; z < neighbor.size(); ++z){
					if (neighbor[z].number() == noSelectNode[j].number())
						break;
				}
				if (z == neighbor.size())
					neighbor.push_back(noSelectNode[j]);
			}
		}
		//		cout << "neighbor size=" << neighbor.size() << endl;
		//		cout << "neighbor=";
		//		for (size_t i = 0; i < neighbor.size(); ++i)
		//			cout << neighbor[i].number() << " ";
		//		cout << endl;
		return neighbor;
	}
	vector<NODE> findShareNeighbor(vector<NODE> neighbor, NODE node, vector<NODE> SelectNodes, vector<vector<double>> world){
		vector<NODE> shareNeighbor;
		vector<NODE> nodes;
		nodes.push_back(node);
		vector<NODE> nodesNeighbor = findNeighbor(nodes, SelectNodes, world);
		cout << "shareNeighbor=" << node.number() << " " << nodesNeighbor.size() << endl;
		for (size_t i = 0; i < nodesNeighbor.size(); ++i)
			cout << nodesNeighbor[i].number() << " ";
		cout << endl;
		for (size_t i = 0; i < nodesNeighbor.size(); ++i){
			for (size_t j = 0; j < neighbor.size(); ++j){
				if (nodesNeighbor[i].number() == neighbor[j].number()){
					shareNeighbor.push_back(neighbor[j]);
					break;
				}
			}
		}
		return shareNeighbor;
	}
	void findFisrtNeighbor(AREA& area, vector<NODE>& noSelectNode, vector<vector<double>> world){
		vector<NODE> denseNeighbor = findNeighbor(area.node(), noSelectNode, world);
		for (size_t i = 0; i < denseNeighbor.size(); ++i){
			area.insert(denseNeighbor[i]);
			for (size_t j = 0; j < noSelectNode.size(); ++j){
				if (denseNeighbor[i].number() == noSelectNode[j].number()){
					noSelectNode.erase(noSelectNode.begin() + j);
					break;
				}
			}
		}
	}
	double findQ(AREA a, NODE selectNode, vector<vector<double>> world, vector<NODE> netNode){
		vector<NODE> aNode = a.node();
		double Li = 0, Lm = 0;
		aNode.push_back(selectNode);
		for (size_t i = 0; i < aNode.size(); ++i){
			for (size_t j = 0; j < netNode.size(); ++j){
				if (world[aNode[i].number() - 1][j]>0){
					if (a.isNode(netNode[j]))
						Li++;
					else
						Lm++;
				}
			}
		}
		return Li / (Li + Lm);
	}
public:
	vector<AREA> FNG_Start(vector<vector<double>> world, vector<NODE> netNode){
		cout << "We will make NG Algorithm!" << endl;
		vector<AREA> ret;//输出脆弱区域集
		vector<NODE> noSelectNode(netNode);//识别节点是否读取
		int i = 0;
		vector<NODE> neighbor;//邻接节点集
		while (!noSelectNode.empty()){
			AREA a;//存放脆弱区域
			a.number(++i);
			a.insert(findFirstNode(noSelectNode));//首个脆弱节点
			neighbor.clear();
			findFisrtNeighbor(a, noSelectNode, world);//初始稠密邻接节点集
			double maxQ = 0;
			while (!noSelectNode.empty()){
				neighbor = findNeighbor(a.node(), noSelectNode, world);//寻找邻接节点集
				int select;
				double Q = 0;
				for (size_t i = 0; i < neighbor.size(); ++i){
					double Qk = findQ(a, netNode[neighbor[i].number() - 1], world, netNode);//计算Qk值
					if (Qk>Q){
						Q = Qk;
						select = i;
					}
				}
				if (Q >= maxQ){
					maxQ = Q;
					a.insert(neighbor[select]);
					for (size_t z = 0; z < noSelectNode.size(); ++z){
						if (noSelectNode[z].number() == neighbor[select].number()){
							noSelectNode.erase(noSelectNode.begin() + z);
							break;
						}
					}
				}
				else
					break;
			}
			a.q(maxQ);
			//			cout << "Area node=";
			//			for (size_t i = 0; i < a.nodeSize(); ++i)
			//				cout << a.node()[i].number()<<" ";
			//			cout << maxQ << endl;
			ret.push_back(a);
		}
		return ret;
	}

public:
	FNG_Algorithm(){
		name("FNG");
	}
	~FNG_Algorithm(){}
private:
};
#endif