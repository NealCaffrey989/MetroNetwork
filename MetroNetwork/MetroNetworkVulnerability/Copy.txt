#pragma once
#ifndef Network_H
#define Network_H

#include "Node.h"
#include "NG_Algorithm.h"
#include <iostream>
#include <windows.h>
#include <vector>
#include <fstream>
#include <string>
#include <iomanip>
#include <map>
#include <algorithm>

using namespace std;

class NETWORK{};

class METRONETWORK:public NETWORK{
private:
	void netAnalyse(void){
		readTime("Netwoke Analyse START Time:");
//		printWorld(World);
		Degree();
		Betweenness();
		Vulnerability();
		printNodeData();
//		printLineData();
		readTime("Netwoke Analyse END Time:");
	}
	void netVulnerabilityAnalyse(void){
		readTime("Netwoke Vulnerability Analyse START Time:");
		

		NG_algorithm();
//		makeKnitmesh();
		readTime("Netwoke Analyse END Time:");
	}
	int findFirstNode(vector<bool> &bubble){
		double maxb = 0, num = 0;
		for (int i = 0; i < netNode.size(); i++){
			if (bubble[i] == true && (maxb<netNode[i].vulnerability() || maxb == 0)){
				num = i;
				maxb = netNode[i].vulnerability();
			}
		}
		bubble[num] = false;
		return num;
	}

	void NG_algorithm(void){
		NG_Algorithm ng_Algo;
		netArea.clear();
		netArea=ng_Algo.NG_Start(World, netNode);
		printAreaData();
	}
	void makeKnitmesh(int n=5,int m=6){
		cout << "We will make Knitmesh!" << endl;
		vector<bool> bubble(netNode.size(),true);
	
/*		int i = 1;
		while (i&&m--){
			AREA a;
			a.number(i);
			a.insert(netNode[findFirstNode(bubble)]);
			bool sign = true;
			int select = a.node()[0].degree()>=2?2:a.node()[0].degree();
			int firstSelect = a.node()[0].number() - 1;
			cout << firstSelect << endl;
			while (select--){
				int dnum = -1;
				for (int j = 0; j < netNode.size(); j++){
					if (World[firstSelect][j]>0 && bubble[j] == true){
						if (dnum == -1)
							dnum = j;
						else{
							if (World[firstSelect][dnum] > World[firstSelect][j])
								dnum = j;
						}
					}
				}
				a.insert(netNode[dnum]);
				bubble[dnum] = false;
			}

		}*/
		for (int i = 0; i < m; i++){
			AREA a;
			a.number(i + 1);
			a.insert(netNode[findFirstNode(bubble)]);
			bool sign = true;
			while (a.nodeSize() <= n-1&&sign==true){
				sign = false;
				double maxl = 0;
				int nf = 0,nl;
				for (int i = 0; i < a.node().size(); i++){
					for (int j = 0; j < netNode.size(); j++){
						if (bubble[j] == true && World[a.node()[i].number() - 1][j]>0 && (maxl<(netNode[a.node()[i].number() - 1].vulnerability()*netNode[j].vulnerability() / World[a.node()[i].number() - 1][j]))){
							maxl = netNode[a.node()[i].number() - 1].vulnerability()*netNode[j].vulnerability() / World[a.node()[i].number() - 1][j];
							nl = j;
							nf = a.node()[i].number() - 1;
							sign = true;
						}
					}
				}
//				cout << nf << " " << nl << endl;
				a.insert(netNode[nl]);
				bubble[nl] = false;
				vector<NODE> n;
				if (nl <= nf){
					n.push_back(netNode[nl]);
					n.push_back(netNode[nf]);
				}
				else{
					n.push_back(netNode[nf]);
					n.push_back(netNode[nl]);
				}
				LINE l;
				l.linenode(n);
				a.insert(l);
			}
			netArea.push_back(a);
		}
		for (int i = 0; i < netNode.size(); i++){
			if (bubble[i]==true)
				otherArea.insert(netNode[i]);
		}
		for (int i = 0; i < netArea.size(); i++){
			long double nV = 0;
			for (int j = 0; j < netArea[i].nodeSize(); j++){
				nV += netArea[i].node()[j].vulnerability();
			}
			netArea[i].vulnerability(nV / netArea[i].nodeSize());
		}
		long double nV = 0;
		for (int i = 0; i < otherArea.nodeSize(); i++){
			nV += otherArea.node()[i].vulnerability();
		}
		otherArea.vulnerability(nV / otherArea.nodeSize());/**/
	}
private:
	void readNodeData(void){
		ifstream datfile;
		string path = "D:\\Program\\C++\\MetroNetwork\\Data\\name_all.dat";
		datfile.open(path);
		int n;
		datfile >> n;
		for (int i = 0; i < n; i++){
			NODE node;
			int num, linenum, flow;
			datfile >> num >> flow >> linenum;
			vector<int> line(linenum, 0);
			for (int i = 0; i < linenum; i++){
				datfile >> line[i];
			}
			node.number(num);
			node.flow(flow);
			node.linenumber(line);
			netNode.push_back(node);
		}
		datfile.close();
	}
	void readNodeLineData(void){
		ifstream datfile;
		string path = "D:\\Program\\C++\\MetroNetwork\\Data\\len_all.dat";
		datfile.open(path);
		World = new vector<double>[netNode.size()];
		for (int i = 0; i < netNode.size(); ++i){
			for (int j = 0; j < netNode.size(); ++j){
				double num;
				datfile >> num;
				World[i].push_back(num);
				if (num>0){
					LINE x;
					x.linelen(num);
					vector<NODE> y;
					if (i <= j){
						y.push_back(NODE(i + 1));
						y.push_back(NODE(j + 1));
					}
					else{
						y.push_back(NODE(j + 1));
						y.push_back(NODE(i + 1));
					}
					x.linenode(y);
					netLine.push_back(x);
				}
			}
		}
		datfile.close();
		for (int i = 0; i < netNode.size(); ++i)
		for (int j = 0; j < i; ++j)
			World[i][j] = World[j][i];
	}

	void Degree(void){
		netDegree = 0;
		for (int i = 0; i < netNode.size(); i++){
			int count = 0;
			for (int j = 0; j < netNode.size(); j++){
				if (World[i][j]>0){
					count++;
				}
			}
			netNode[i].degree(count);
		}
		for (int i = 0; i < netNode.size(); i++)
			netDegree += netNode[i].degree();

		netDegree = netDegree / netNode.size();
	}
	void Betweenness(void){
		netBetweenness = 0;
		int k = 1;
		vector<bool> netmap;
		for (int i = 0; i < netNode.size(); i++)
			netmap.push_back(true);
		while (find(netmap.begin(),netmap.end(),true)!=netmap.end()){
			vector< pair<int, double> > btness;
			for (int i = 0; i < netNode.size(); i++){
				if (netmap[i] == true && netNode[i].degree() == 1){
					btness.push_back(make_pair(i, 2.0 / netNode.size()));
					netmap[i] = false;
//					cout << "i=" << i << "     " << netNode[i].degree() << "     " << netNode[i].betweenness() << " " << k << endl;
				}
				else if (netmap[i] == true && netNode[i].degree() >= 2){
					double minb = 0;
					for (int j = 0; j < netNode.size(); j++){
						if (World[i][j]>0 && netNode[j].betweenness() > 0) {
							if (minb == 0 || minb > netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1))){
								minb = netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1));
							}
						}
					}
					if (minb != 0){
						btness.push_back(make_pair(i, minb));
						netmap[i] = false;
//						cout << "i=" << i << "     " << netNode[i].degree() << "     " << netNode[i].betweenness() <<" "<<k<< endl;
					}
				}
			}
			for (int i = 0; i < btness.size(); i++)
				netNode[btness[i].first].betweenness(btness[i].second);
			btness.clear();
			k++;
		}
		vector< pair<int, double> > btness;
		for (int i = 0; i < netNode.size(); i++){
			if (netNode[i].degree()>2){
				double minb = netNode[i].betweenness();
				for (int j = 0; j < netNode.size(); j++){
					if (World[i][j]>0) {
						if (minb < netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1))){
							minb = netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1));
						}
					}
				}
				if (minb>netNode[i].betweenness())
					btness.push_back(make_pair(i, minb));
			}
		}
		for (int i = 0; i < btness.size(); i++)
			netNode[btness[i].first].betweenness(btness[i].second);
//		printNodeData();
	}
	void Vulnerability(double alph=0){
		double maxb = netNode[0].betweenness(), minb = maxb;
		double maxf = netNode[0].flow(), minf = maxf;
		for (int i = 1; i < netNode.size(); i++){
			if (maxb < netNode[i].betweenness())
				maxb = netNode[i].betweenness();
			if (minb > netNode[i].betweenness())
				minb = netNode[i].betweenness();
			if (maxf < netNode[i].flow())
				maxf = netNode[i].flow();
			if (minf > netNode[i].flow())
				minf = netNode[i].flow();
		}
		for (int i = 0; i < netNode.size(); i++){
			netNode[i].vulnerability((netNode[i].betweenness() - minb)*(1 - alph) / (maxb - minb) + (netNode[i].flow() - minf)*alph / (maxf - minf));
		}
	}

	void readTime(string const meg){
		SYSTEMTIME sys;
		GetLocalTime(&sys);
		cout << meg << sys.wMonth << "/" << sys.wDay << "/" << sys.wYear << "  " << sys.wHour << ":" << sys.wMinute << endl;
	}
	void readData(void){
		cout << "First Read The Data!" << endl;
		readNodeData();
		readNodeLineData();
		readTime("Metro Data read over time:");
//		printNodeData();
//		printLineData();
//		printWorld(World);
	}

	void printNodeData(void){
		cout << MetroName << "Metor " << netNode.size() << "NODE like this:" << endl;
		cout << setiosflags(ios::right) << setw(8) << setprecision(4);
		for (int i = 0; i < netNode.size(); i++){
			cout << setiosflags(ios::right) << setw(8) << netNode[i].number();
			cout << setiosflags(ios::right) << setw(8) << netNode[i].flow();
			cout << setiosflags(ios::right) << setw(8) << netNode[i].degree();
			cout << setiosflags(ios::right) << setw(8) << netNode[i].betweenness();
			cout << setiosflags(ios::right) << setw(8) << netNode[i].vulnerability();
			for (int j = 0; j < netNode[i].linenumber().size(); j++)
				cout << setiosflags(ios::right) << setw(8) << netNode[i].linenumber()[j];
			cout << endl;
		}
	}
	void printLineData(void){
		cout << MetroName << "Metor " << netLine.size() << "LINE like this:" << endl;
		for (int i = 0; i < netLine.size(); i++){
			cout << setiosflags(ios::right) << setw(2) << netLine[i].linenode()[0].number() << "-" << netLine[i].linenode()[1].number() << setw(4);
			cout << setiosflags(ios::right) << setw(8) << netLine[i].linelen() << endl;
		}
	}
	void printAreaData(void){
		cout << MetroName << "Metor " << netArea.size() << "  Area like this:" << endl;
		for (int i = 0; i < netArea.size(); i++){
			cout << "Area " << setiosflags(ios::right) << setw(2) << netArea[i].number();
			cout << "  has " << setiosflags(ios::right) << setw(2) << netArea[i].nodeSize() << " Node";
			cout << "  and " << setiosflags(ios::right) << setw(2) << netArea[i].lineSize() << " Line."; 
			cout << "  vulnerability = " << setiosflags(ios::right) << setw(2) << netArea[i].vulnerability() << " .";
			cout << endl;
			vector<NODE> n = netArea[i].node();
			cout << "Node :";
			for (int i = 0; i < n.size();i++)
				cout << setiosflags(ios::right) << setw(4) << n[i].number();
			cout << endl;
			vector<LINE> l = netArea[i].line();
			cout << "Line :";
			for (int i = 0; i < l.size(); i++){
				cout << setiosflags(ios::right) << setw(2) << l[i].linenode()[0].number() << "-"<<l[i].linenode()[1].number()<<"    ";
			}				
			cout << endl;
		}

		cout << endl << "Other Area Vulnerability = " << setiosflags(ios::right) << setw(2) << otherArea.vulnerability() << " ." << endl;
	}
	void printWorld(vector<double> const *pWorld){
		for (int i = 0; i <= netNode.size(); i++)
			cout << setiosflags(ios::right) << setw(8) << i;
		cout << endl;
		for (int i = 0; i<netNode.size(); i++){
			cout << setiosflags(ios::right) << setw(8) << i + 1;
			for (int j = 0; j<netNode.size(); j++)
				cout << setiosflags(ios::fixed) << setiosflags(ios::right) << setw(8) << setprecision(4) << pWorld[i][j];
			cout << endl;
		}
	}

	void writeAreaDate(void){
		ofstream outfile;
		string path = "D:\\Program\\C++\\MetroNetwork\\Data\\Areavulnerability.dat";
		outfile.open(path);
		outfile.clear();
		outfile << netArea.size()+1 <<  endl;
		for (int i = 0; i < netArea.size(); i++){
			outfile << netArea[i].number() << setiosflags(ios::right) << setw(2);
			outfile << netArea[i].nodeSize() << setiosflags(ios::right) << setw(2);
			outfile << netArea[i].lineSize() << setiosflags(ios::right) << setw(10);
			outfile << netArea[i].vulnerability() << setiosflags(ios::right) ;
			vector<NODE> n = netArea[i].node();
			for (int i = 0; i < n.size(); i++)
				outfile << setiosflags(ios::right) << setw(4) << n[i].number();
			outfile << endl;
		}
		outfile << otherArea.vulnerability() << endl;
		outfile.close();
	}

private:
	void createConnectedWorld(vector<int> *pWorld){
		bool sign = false;
		for (;;){
			for (int i = 0; i < netNode.size(); i++){
				for (int j = 0; j < netNode.size(); j++){
					for (int z = 0; z < netNode.size(); z++){
						if (pWorld[i][z]>pWorld[i][j] + pWorld[j][z] || pWorld[i][z] == -1){

						}
					}
				}
			}
		}
		//		vector<int> *b = new vector<int>[this->netNode.size()];
		//		int temp = 0;
		/*		for (int i = 0; i<this->netNode.size(); i++)
		for (int j = 0; j<this->netNode.size(); j++)
		if (pWorld[i][j]>0 && j != i)
		for (int z = 0; z<this->netNode.size(); z++)
		if (pWorld[j][z]>0 && z != i&&z != j && (pWorld[i][z]>pWorld[i][j] + pWorld[j][z] || pWorld[i][z] == -1)){
		pWorld[i][z] = pWorld[i][j] + pWorld[j][z];
		pWorld[z][i] = pWorld[i][z];
		}
		*/
	}

public:
	void printMetroData(void){
		cout << "We will Analyse ";
		cout << MetroName << " Metro Network!" << endl;
		cout << "It has " << netNode.size() << " Node, and has " << netLine.size() << " Line" << endl;
	}
	void metroVulnerabilityAnalyseStart(void){
		printMetroData();
		cout << endl;

		cout << "Now!We will START THE Metro Vulnerability Analyse!" << endl;
		readTime("Program START Time:");
		cout << endl;

		cout << "First! We will START Netwoke Analyse!" << endl;
		netAnalyse();
		cout << endl;

		cout << "Next! We will START Netwoke Vulnerability Analyse!" << endl;
		netVulnerabilityAnalyse();
		cout << endl;
		writeAreaDate();
	}

public:
	METRONETWORK(void){
		MetroName = "A";
		readData();
	}
	METRONETWORK(string str){
		MetroName = str;
		readData();
	}
	~METRONETWORK(void){}

private:
	string MetroName;
	vector<NODE> netNode;
	vector<LINE> netLine;
	vector<AREA> netArea;
	AREA otherArea;
	vector<double> *World;

private:
	double netDegree;
	double netBetweenness;
};


#endif;