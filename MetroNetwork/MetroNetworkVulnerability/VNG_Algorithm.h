#pragma once
#ifndef VNG_ALGORITHM_H
#define VNG_ALGORITHM_H
#include "Node.h"
#include "Algorithm.h"
#include <iostream>
#include <vector>
using namespace std;
class VNG_Algorithm :public Algorithm{
private:
	NODE findFirstNode(vector<NODE>& noSelectNode){
		double maxb = 0;
		size_t num = 0;
		for (size_t i = 0; i < noSelectNode.size(); i++){
			if (maxb<noSelectNode[i].vulnerability() || maxb == 0){
				num = i;
				maxb = noSelectNode[i].vulnerability();
			}
		}
		NODE nde = noSelectNode[num];
		noSelectNode.erase(noSelectNode.begin() + num);
		return nde;
	}
	vector<NODE> findNeighbor(vector<NODE> aNode, vector<NODE> noSelectNode, vector<vector<double>> world){
		vector<NODE>neighbor;
		for (size_t i = 0; i < aNode.size(); ++i){
			for (size_t j = 0; j < noSelectNode.size(); ++j)
			if (world[aNode[i].number() - 1][noSelectNode[j].number() - 1]>0){
				size_t z = 0;
				for (; z < neighbor.size(); ++z){
					if (neighbor[z].number() == noSelectNode[j].number())
						break;
				}
				if (z == neighbor.size())
					neighbor.push_back(noSelectNode[j]);
			}
		}
		//		cout << "neighbor size=" << neighbor.size() << endl;
		//		cout << "neighbor=";
		//		for (size_t i = 0; i < neighbor.size(); ++i)
		//			cout << neighbor[i].number() << " ";
		//		cout << endl;
		return neighbor;
	}
	vector<NODE> findShareNeighbor(vector<NODE> neighbor, NODE node, vector<NODE> SelectNodes, vector<vector<double>> world){
		vector<NODE> shareNeighbor;
		vector<NODE> nodes;
		nodes.push_back(node);
		vector<NODE> nodesNeighbor = findNeighbor(nodes, SelectNodes, world);
		cout << "shareNeighbor=" << node.number() << " " << nodesNeighbor.size() << endl;
		for (size_t i = 0; i < nodesNeighbor.size(); ++i)
			cout << nodesNeighbor[i].number() << " ";
		cout << endl;
		for (size_t i = 0; i < nodesNeighbor.size(); ++i){
			for (size_t j = 0; j < neighbor.size(); ++j){
				if (nodesNeighbor[i].number() == neighbor[j].number()){
					shareNeighbor.push_back(neighbor[j]);
					break;
				}
			}
		}
		return shareNeighbor;
	}
	void findFisrtNeighbor(AREA& area, vector<NODE>& noSelectNode, vector<vector<double>> world){
		vector<NODE> denseNeighbor = findNeighbor(area.node(), noSelectNode, world);
		for (size_t i = 0; i < denseNeighbor.size(); ++i){
			area.insert(denseNeighbor[i]);
			for (size_t j = 0; j < noSelectNode.size(); ++j){
				if (denseNeighbor[i].number() == noSelectNode[j].number()){
					noSelectNode.erase(noSelectNode.begin() + j);
					break;
				}
			}
		}
	}
	double findQ(AREA a, NODE selectNode, vector<vector<double>> world, vector<NODE> netNode){
		vector<NODE> aNode = a.node();
		double Li = 0, Lm = 0;
		aNode.push_back(selectNode);
		for (size_t i = 0; i < aNode.size(); ++i){
			for (size_t j = 0; j < netNode.size(); ++j){
				if (world[aNode[i].number() - 1][j]>0){
					if (a.isNode(netNode[j]))
						Li++;
					else
						Lm++;
				}
			}
		}
		return Li / (Li + Lm);
	}
public:
	vector<AREA> VNG_Start(vector<vector<double>> world, vector<NODE> netNode){
		cout << "We will make VNG Algorithm!" << endl;
		vector<AREA> ret;//输出脆弱区域集
		vector<NODE> noSelectNode(netNode);//识别节点是否读取
		int i = 0;
		vector<NODE> neighbor;//邻接节点集
		while (!noSelectNode.empty()){
			AREA a;//存放脆弱区域
			a.number(++i);
			a.insert(findFirstNode(noSelectNode));//首个脆弱节点
			neighbor.clear();
			findFisrtNeighbor(a,noSelectNode,world);//初始稠密邻接节点集
			double maxQ = 0, minv=a.vulnerability();
			cout << minv << endl;
			while (!noSelectNode.empty()){
				neighbor = findNeighbor(a.node(), noSelectNode, world);//寻找邻接节点集
				int select;
				double Q = 0;
				for (size_t i = 0; i < neighbor.size(); ++i){
					double Qk = findQ(a, netNode[neighbor[i].number() - 1], world, netNode);//计算Qk值
					if (Qk>Q){
						Q = Qk;
						select = i;
					}
				}
				if (Q >= maxQ&&neighbor[select].vulnerability()>=minv){
					maxQ = Q;
					a.insert(neighbor[select]);
					for (size_t z = 0; z < noSelectNode.size(); ++z){
						if (noSelectNode[z].number() == neighbor[select].number()){
							noSelectNode.erase(noSelectNode.begin() + z);
							break;
						}
					}
				}
				else
					break;
			}
			a.q(maxQ);
			cout << "Area node=";
			for (size_t i = 0; i < a.nodeSize(); ++i)
				cout << a.node()[i].number()<<" ";
			cout << maxQ << endl;
			ret.push_back(a);
		}
		return ret;
	}
public:
	VNG_Algorithm(){
		name("VNG");
	}
	~VNG_Algorithm(){}
};
/*
void makeKnitmesh(int n = 5, int m = 6){
cout << "We will make Knitmesh!" << endl;
vector<bool> bubble(netNode.size(), true);

/*		int i = 1;
while (i&&m--){
AREA a;
a.number(i);
a.insert(netNode[findFirstNode(bubble)]);
bool sign = true;
int select = a.node()[0].degree()>=2?2:a.node()[0].degree();
int firstSelect = a.node()[0].number() - 1;
cout << firstSelect << endl;
while (select--){
int dnum = -1;
for (int j = 0; j < netNode.size(); j++){
if (World[firstSelect][j]>0 && bubble[j] == true){
if (dnum == -1)
dnum = j;
else{
if (World[firstSelect][dnum] > World[firstSelect][j])
dnum = j;
}
}
}
a.insert(netNode[dnum]);
bubble[dnum] = false;
}

}*//*
for (int i = 0; i < m; i++){
AREA a;
a.number(i + 1);
a.insert(netNode[findFirstNode(bubble)]);
bool sign = true;
while (a.nodeSize() <= n - 1 && sign == true){
sign = false;
double maxl = 0;
int nf = 0, nl;
for (int i = 0; i < a.node().size(); i++){
for (int j = 0; j < netNode.size(); j++){
if (bubble[j] == true && World[a.node()[i].number() - 1][j]>0 && (maxl<(netNode[a.node()[i].number() - 1].vulnerability()*netNode[j].vulnerability() / World[a.node()[i].number() - 1][j]))){
maxl = netNode[a.node()[i].number() - 1].vulnerability()*netNode[j].vulnerability() / World[a.node()[i].number() - 1][j];
nl = j;
nf = a.node()[i].number() - 1;
sign = true;
}
}
}
//				cout << nf << " " << nl << endl;
a.insert(netNode[nl]);
bubble[nl] = false;
vector<NODE> n;
if (nl <= nf){
n.push_back(netNode[nl]);
n.push_back(netNode[nf]);
}
else{
n.push_back(netNode[nf]);
n.push_back(netNode[nl]);
}
LINE l;
l.linenode(n);
a.insert(l);
}
netArea.push_back(a);
}
for (int i = 0; i < netNode.size(); i++){
if (bubble[i] == true)
otherArea.insert(netNode[i]);
}
}*/

#endif