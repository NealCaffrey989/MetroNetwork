#pragma once
#ifndef NTVULNERABILITYANALYSE_H
#define NTVULNERABILITYANALYSE_H
#include "Network.h"
#include "Copyright.h"
#include "flow_time.h"
#include "NG_Algorithm.h"
#include "FNG_Algorithm.h"
#include <iostream>
#include <map>
#include <algorithm>
#include <iomanip>
#include <windows.h>
using namespace std;

class NetVulnerabilityAnalyse{
private:
	void print_program(void){
		cout << "Welcome to our program!We will use some algorithm to analyse some network" << endl;
		print_Line();
	}
	void print_Line(void){
		cout << "----------------------------------------------------------------------------------------------" << endl;
	}
	void printMessage(string const meg){
		cout << meg << endl;
	}
	void readTime(string const meg){
		SYSTEMTIME sys;
		GetLocalTime(&sys);
		cout << meg << sys.wMonth << "/" << sys.wDay << "/" << sys.wYear << "  " << sys.wHour << ":" << sys.wMinute << ":" << sys.wSecond << endl;
	}

private:
	int readWorldType(void){
		cout << "Please select a World Type." << endl;
		cout << "If your already have a Network message, please select type 1. Or you can select 2 to fabricate a world you like." << endl;
		int worldType;
		do{
			cout << "world type = ";
			cin >> worldType;
			if (worldType>0 && worldType<3)
				break;
		} while (1);
		cout << endl;
		return worldType;
	}
	void makeNetwork(void){
		printMessage("Please select network type!");
		printMessage("NO.1 represent Actual Network and NO.2 represent Virtual Network!!");
		switch (readWorldType()){
			case 1:
				readTime("Actual Network create now!");
				createActualNetwork();
				break;
			case 2:
				readTime(" Virtual Network create now!");
				createVirtualNetwork();
				break;
			default:
				printMessage("Can't make Network!");
				break;
		}
		readTime("Create over!");
		print_Line();
	}
	void createActualNetwork(void){
		METRONETWORK metro;
		metro.create();
		metro.name("Guangzhou Metro");
		network.name(metro.name());
		network.node(metro.node());
		network.line(metro.line());
		network.World = metro.World;
	};
	void createVirtualNetwork(void){};

private:
	void printNetworkData(void){
		cout << "We will Analyse ";
		cout << network.name() << " Network!" << endl;
		cout << "It has " << network.nodeSize() << " Node, and has " << network.lineSize() << " Line" << endl;
	}
	void printNodeData(vector<NODE> netNode){
		cout << network.name() << "Metor " << netNode.size() << "NODE like this:" << endl;
		cout << setiosflags(ios::right) << setw(8) << setprecision(4);
		for (size_t i = 0; i < netNode.size(); i++){
			cout << setiosflags(ios::right) << setw(8) << netNode[i].number();
			cout << setiosflags(ios::right) << setw(12) << netNode[i].name();
			cout << setiosflags(ios::right) << setw(8) << netNode[i].flow();
			cout << setiosflags(ios::right) << setw(8) << netNode[i].degree();
			cout << setiosflags(ios::right) << setw(12) << netNode[i].betweenness();
			cout << setiosflags(ios::right) << setw(8) << netNode[i].vulnerability();
			for (size_t j = 0; j < netNode[i].linenumber().size(); j++)
				cout << setiosflags(ios::right) << setw(8) << netNode[i].linenumber()[j];
			cout << endl;
		}
	}
	void printLineData(vector<LINE> netLine){
		cout << network.name() << "Metor " << netLine.size() << "NODE like this:" << endl;
		for (size_t i = 0; i < netLine.size(); i++){
			cout << setiosflags(ios::right) << setw(2) << netLine[i].linenode()[0].number() << "-" << netLine[i].linenode()[1].number() << setw(4);
			cout << setiosflags(ios::right) << setw(8) << netLine[i].linelen() << endl;
		}
	}
	void printAreaData(vector<AREA> netArea){
		cout << network.name() << "Metor " << netArea.size() << "  Area like this:" << endl;
		for (size_t i = 0; i < netArea.size(); i++){
			cout << "Area " << setiosflags(ios::right) << setw(2) << netArea[i].number();
			cout << "  has " << setiosflags(ios::right) << setw(2) << netArea[i].nodeSize() << " Node";
			cout << "  and " << setiosflags(ios::right) << setw(2) << netArea[i].lineSize() << " Line.";
			cout << "  vulnerability = " << setiosflags(ios::right) << setw(2) << netArea[i].vulnerability() << " .";
			cout << endl;
			vector<NODE> n = netArea[i].node();
			cout << "Node :";
			for (size_t j = 0; j < n.size(); j++)
				cout << setiosflags(ios::right) << setw(4) << n[j].number();
			cout << endl;
			vector<LINE> l = netArea[i].line();
			cout << "Line :";
			for (size_t j = 0; j < l.size(); j++)
				cout << setiosflags(ios::right) << setw(2) << l[j].linenode()[0].number() << "-" << l[j].linenode()[1].number() << "    ";
			cout << endl;
		}
	}
	void printWorld(vector<vector<double>> const pWorld){
		for (size_t i = 0; i <= pWorld.size(); i++)
			cout << setiosflags(ios::right) << setw(8) << i;
		cout << endl;
		for (size_t i = 0; i<pWorld.size(); i++){
			cout << setiosflags(ios::right) << setw(8) << i + 1;
			for (size_t j = 0; j<pWorld.size(); j++)
				cout << setiosflags(ios::fixed) << setiosflags(ios::right) << setw(8) << setprecision(4) << pWorld[i][j];
			cout << endl;
//			system("Pause");
		}
	}
	void printLine(vector<vector<double>> const pWorld){
		for (size_t i = 0; i<pWorld.size(); i++){
			cout << setiosflags(ios::right) << setw(14) << i + 1<<" "<<network.node()[i].name();
			for (size_t j = 0; j < pWorld.size(); j++){
				if (pWorld[i][j] > 0)
					cout << setiosflags(ios::fixed) << setiosflags(ios::right) << setw(18) << network.node()[j].name();
			}
			cout << endl;
//			system("Pause");
		}
	}
	void printDegree(void){
		vector<NODE> node = network.node();
		map<double, int> degreeMap;
		for (size_t i = 0; i < node.size(); ++i)
				degreeMap[node[i].degree()]++;
		for (map<double, int>::const_iterator iter = degreeMap.begin(); iter != degreeMap.end(); ++iter)
			cout << (*iter).first << " " << (*iter).second << " " << double((*iter).second) / node.size() << endl;
	}
	void writeNetworkData(void){
		ofstream outfile;
		outfile.open(path + al_name + "_" + network.name() + "Network_Data.dat");
		outfile.clear();
		outfile << network.name() << "Metor " << network.nodeSize() << "NODE like this:" << endl;
		outfile << setiosflags(ios::right) << setw(8) << setprecision(4);
		vector<NODE> netNode = network.node();
		for (size_t i = 0; i < network.nodeSize(); i++){
			outfile << setiosflags(ios::right) << setw(8) << netNode[i].number();
			outfile << setiosflags(ios::right) << setw(12) << netNode[i].name();
			outfile << setiosflags(ios::right) << setw(8) << netNode[i].flow();
			outfile << setiosflags(ios::right) << setw(8) << netNode[i].degree();
			outfile << setiosflags(ios::right) << setw(12) << netNode[i].betweenness();
			outfile << setiosflags(ios::right) << setw(8) << netNode[i].vulnerability();
			for (size_t j = 0; j < netNode[i].linenumber().size(); j++)
				outfile << setiosflags(ios::right) << setw(8) << netNode[i].linenumber()[j];
			outfile << endl;
		}
		outfile.close();
	}
	void writeAreaData(void){
		ofstream outfile;
		outfile.open(path + al_name + "_" + network.name() + "Network_Areavulnerability.dat");
		outfile.clear();
		outfile << netArea.size() + 1 << endl;
		for (size_t i = 0; i < netArea.size(); i++){
			outfile << netArea[i].number() << setiosflags(ios::right) << setw(2);
			outfile << netArea[i].nodeSize() << setiosflags(ios::right) << setw(2);
			outfile << netArea[i].lineSize() << setiosflags(ios::right) << setw(10);
			outfile << netArea[i].vulnerability() << setiosflags(ios::right) << setw(10);
			outfile << netArea[i].q() << setiosflags(ios::right);
			vector<NODE> n = netArea[i].node();
			for (size_t i = 0; i < n.size(); i++)
				outfile << setiosflags(ios::right) << setw(4) << n[i].number() << n[i].name();
			outfile << endl;
		}
		outfile.close();
	}
public:
	void Start(void){
		COPYRIGHT cr("NetVulnerabilityAnalyse", "1.3.2", "2015", "Gong Jian");
		cr.Print_copyright();
		print_program();
		printMessage("First make a network!");
		makeNetwork();

		network.readFlow("flow_t1.dat");
		writeNetworkData();

		printDegree();
//		printNodeData(network.node());
//		printLineData(network.line());
//		timeslot omg = network.readFlow();
	}
public:
	NetVulnerabilityAnalyse() :path("D:\\Program\\GitHub\\MetroNetwork\\MetroNetwork\\Data\\"){}
	~NetVulnerabilityAnalyse(){}
private:
	string al_name;
	string path;
	vector<AREA> netArea;
	NETWORK network;
};

class timeforSlot{
	void start(){
		NG_Algorithm ng_Algo;
		netArea.clear();
		readTime("Now! We will use NG Algorithm to find vulnerable areas!");
		al_name = ng_Algo.name();
		netArea = ng_Algo.NG_Start(network.World, network.node());
		readTime("Find over!");
		writeAreaData();
		FNG_Algorithm fng_Algo;
		netArea.clear();
		readTime("Now! We will use VNG Algorithm to find vulnerable areas!");
		al_name = fng_Algo.name();
		netArea = fng_Algo.FNG_Start(network.World, network.node());
		readTime("Find over!");
		//		printAreaData(netArea);
		writeAreaData();/**/
	}
	string al_name;
	vector<AREA> netArea;
	NETWORK network;
};


#endif