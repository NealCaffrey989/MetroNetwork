#pragma once
#ifndef Network_H
#define Network_H

#include "Node.h"
#include "NG_Algorithm.h"
#include <iostream>
#include <fstream>

#include <string>
#include <vector>
//#include <algorithm>
using namespace std;

string path = "D:\\Program\\GitHub\\MetroNetwork\\MetroNetwork\\Data\\";

class NETWORK{
public:
	string name(void){
		return netName;
	}
	void name(string name){
		netName = name;
	}
	void insert(NODE node){
		netNode.push_back(node);
	}
	void insert(LINE line){
		netLine.push_back(line);
	}
	size_t nodeSize(void){
		return netNode.size();
	}
	size_t lineSize(void){
		return netLine.size();
	}
	vector<NODE> node(){
		return netNode;
	}
	void node(vector<NODE> nodes){
		netNode = nodes;
	}
	vector<LINE> line(){
		return netLine;
	}
	void line(vector<LINE> lines){
		netLine = lines;
	}
	vector< vector<double> > World;
	double degree(void){
		return this->netDegree;
	}
	void setDegree(void){
		netDegree = 0;
		for (size_t i = 0; i < netNode.size(); i++){
			int count = 0;
			for (size_t j = 0; j < netNode.size(); j++){
				if (World[i][j]>0){
					count++;
				}
			}
			netNode[i].degree(count);
		}
		for (size_t i = 0; i < netNode.size(); i++)
			netDegree += netNode[i].degree();
		netDegree = netDegree / netNode.size();
		cout << "Degree->" << netDegree << endl;
	}
	vector<int> getPath(int start){
		int N = nodeSize();
		vector<int> path(N);
		vector<bool> used(N);
		vector<double> minDis(N);
		for (int i = 0; i < N; i++){
			path[i] = -1;
			minDis[i] = -1.0;
		}
		used[start] = true;
		minDis[start] = 0.0;

		for (int i = 1; i < N; i++){
			for (int j = 0; j < N; j++){
				if (used[j] == true || World[start][j] < 0)
					continue;
				if (World[start][j] >= 0.0 && (minDis[j] < 0.0 || minDis[j] > minDis[start] + World[start][j])){
					path[j] = start;
					minDis[j] = minDis[start] + World[start][j];
				}
			}
			start = -1;
			for (int j = 0; j < N; j++){
				if (minDis[j] < 0.0 || used[j] == true)
					continue;
				if (start == -1 || minDis[start] > minDis[j]){
					start = j;
					used[start] = true;
				}
			}
			if (start == -1){
				break;
			}
		}
		return path;
	}
	void getBetweeness(){
		int N = nodeSize();
		vector<double> b (N);
		for (int start = 0; start < N; start++){
			vector<int> path = getPath(start);    // 保存树的结构
			vector<int> num(N);            // 一个节点的路径的数目
			vector<int> used (N);        // 0：初始-->1：有子节点  0--->2:把没有子节点的处理
			// 每次处理的时候找到没有子节点的点，然后将它的个数加到它的父节点中
			for (int i = 0; i < N; i++){
				for (int j = 0; j < N; j++){
					if (path[j] != -1 && used[path[j]] == 0)
						used[path[j]] = 1;
				}
				for (int j = 0; j < N; j++){
					if (used[j] == 0 && path[j] >= 0){
						num[path[j]] += 1 + num[j];
						used[j] = 2;
					}
				}
				for (int j = 0; j < N; j++){
					if (used[j] == 1)	{
						used[j] = 0;
					}
				}
			}
			for (int i = 0; i < N; i++){
				b[i] += num[i];
			}
		}

		double sum = N*N - N;
		for (int i = 0; i < N; i++){
			netNode[i].betweenness(b[i] / sum);
		}
	}
	

	void setBetweenness(void){
		netBetweenness = 0;
		int k = 1;
		vector<bool> netmap;
		for (size_t i = 0; i < netNode.size(); i++)
			netmap.push_back(true);
		while (find(netmap.begin(), netmap.end(), true) != netmap.end()){
			vector< pair<int, double> > btness;
			for (size_t i = 0; i < netNode.size(); i++){
				if (netmap[i] == true && netNode[i].degree() == 1){
					btness.push_back(make_pair(i, 2.0 / netNode.size()));
					netmap[i] = false;
					cout << "i=" << i+1 << "     " << netNode[i].degree() << "     " << netNode[i].betweenness() << " " << k << endl;
				}
				else if (netmap[i] == true && netNode[i].degree() >= 2){
					double minb = 0;
					for (size_t j = 0; j < netNode.size(); j++){
						if (World[i][j]>0 && netNode[j].betweenness() > 0) {
							if (minb == 0 || minb > netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1))){
								minb = netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1));
							}
						}
					}
					if (minb != 0){
						btness.push_back(make_pair(i, minb));
						netmap[i] = false;
						cout << "i=" << i+1 << "     " << netNode[i].degree() << "     " << netNode[i].betweenness() <<" "<<k<< endl;
					}
				}
			}
			for (size_t i = 0; i < btness.size(); i++)
				netNode[btness[i].first].betweenness(btness[i].second);
			btness.clear();
			k++;
		}
		vector< pair<int, double> > btness;
		for (size_t i = 0; i < netNode.size(); i++){
			if (netNode[i].degree()>2){
				double minb = netNode[i].betweenness();
				for (size_t j = 0; j < netNode.size(); j++){
					if (World[i][j]>0) {
						if (minb < netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1))){
							minb = netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1));
						}
					}
				}
				if (minb>netNode[i].betweenness())
					btness.push_back(make_pair(i, minb));
			}
		}
		for (size_t i = 0; i < btness.size(); i++)
			netNode[btness[i].first].betweenness(btness[i].second);
		//		printNodeData();
	}
	void setVulnerability(double alph = 0){
		double maxb = netNode[0].betweenness(), minb = maxb;
		double maxf = netNode[0].flow(), minf = maxf;
		for (size_t i = 1; i < netNode.size(); i++){
			if (maxb < netNode[i].betweenness())
				maxb = netNode[i].betweenness();
			if (minb > netNode[i].betweenness())
				minb = netNode[i].betweenness();
			if (maxf < netNode[i].flow())
				maxf = netNode[i].flow();
			if (minf > netNode[i].flow())
				minf = netNode[i].flow();
		}
		cout << maxb << " " << minb << " " << maxf << " " << minf << endl;
		for (size_t i = 0; i < netNode.size(); i++){
			netNode[i].vulnerability((netNode[i].betweenness() - minb)*(1 - alph) / (maxb - minb) +(netNode[i].flow() - minf)*alph / (maxf - minf));
		}
	}
public:
	void readFlow(string name){
		ifstream datfile;
		datfile.open(path + name);
		for (size_t i = 0; i < nodeSize(); ++i){
			int flow;
			datfile >> flow;
			netNode[i].flow(flow);
		}
		datfile.close();
		this->setVulnerability();
	}
	NETWORK(){}
	~NETWORK(){}

private:
	string netName;
	vector<NODE> netNode;
	vector<LINE> netLine;
	
private:
	double netDegree;
	double netBetweenness;
};

class METRONETWORK :public NETWORK{
private:
	void readNodeData(void){
		ifstream datfile;
		string name = "name_all.dat";
		datfile.open(path+name);
		int n;
		datfile >> n;
		while (n--){
			NODE node;
			int num, linenum;
			string node_name;
			datfile >> num >> linenum;
			vector<int> line(linenum, 0);
			for (int i = 0; i < linenum; i++){
				datfile >> line[i];
			}
			datfile >> node_name;
			node.number(num);
			node.linenumber(line);
			node.name(node_name);
			this->insert(node);
		}
		datfile.close();
	}
	void readNodeLineData(void){
		ifstream datfile;
		string name ="len_all.dat";
		datfile.open(path+name);
		for (size_t i = 0; i < this->nodeSize(); ++i){
			vector<double> w;
			for (size_t j = 0; j < this->nodeSize(); ++j){
				double num;
				datfile >> num;
				w.push_back(num);
				if (num>0){
					LINE x;
					x.linelen(num);
					vector<NODE> y;
					if (i <= j){
						y.push_back(NODE(i + 1));
						y.push_back(NODE(j + 1));
					}
					else{
						y.push_back(NODE(j + 1));
						y.push_back(NODE(i + 1));
					}
					x.linenode(y);
					insert(x);
				}
			}
			this->World.push_back(w);
		}
		datfile.close();
		for (size_t i = 0; i < this->nodeSize(); ++i)
			for (size_t j = 0; j < i; ++j)
				World[i][j] = World[j][i];
	}
	
public:
	void create(void){
		cout << "First Read The Data!" << endl;
		readNodeData();
		cout << "Node over!" << endl;
		readNodeLineData();
		cout << "Line over!" << endl;
		this->setDegree();
		cout << "Degree over!" << endl;
		this->setBetweenness();
//		this->getBetweeness();
		cout << "Betweenness over!" << endl;
//		this->setVulnerability();
//		cout << "Vulnerability over!" << endl;
	}
};

class VIRTUTALNETWORK :public NETWORK{

};
#endif;