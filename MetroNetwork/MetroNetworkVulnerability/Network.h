#pragma once
#ifndef Network_H
#define Network_H

#include "Node.h"
#include "NG_Algorithm.h"
#include <iostream>
#include <fstream>

#include <string>
#include <vector>
//#include <algorithm>


using namespace std;

class NETWORK{
public:
	string name(void){
		return netName;
	}
	void name(string name){
		netName = name;
	}
	void insert(NODE node){
		netNode.push_back(node);
	}
	void insert(LINE line){
		netLine.push_back(line);
	}
	size_t nodeSize(void){
		return netNode.size();
	}
	size_t lineSize(void){
		return netLine.size();
	}
	vector<NODE> node(){
		return netNode;
	}
	void node(vector<NODE> nodes){
		netNode = nodes;
	}
	vector<LINE> line(){
		return netLine;
	}
	void line(vector<LINE> lines){
		netLine = lines;
	}
	vector< vector<double> > World;
	void setDegree(void){
		netDegree = 0;
		for (size_t i = 0; i < netNode.size(); i++){
			int count = 0;
			for (size_t j = 0; j < netNode.size(); j++){
				if (World[i][j]>0){
					count++;
				}
			}
			netNode[i].degree(count);
		}
		for (size_t i = 0; i < netNode.size(); i++)
			netDegree += netNode[i].degree();

		netDegree = netDegree / netNode.size();
	}
	void setBetweenness(void){
		netBetweenness = 0;
		int k = 1;
		vector<bool> netmap;
		for (size_t i = 0; i < netNode.size(); i++)
			netmap.push_back(true);
		while (find(netmap.begin(), netmap.end(), true) != netmap.end()){
			vector< pair<int, double> > btness;
			for (size_t i = 0; i < netNode.size(); i++){
				if (netmap[i] == true && netNode[i].degree() == 1){
					btness.push_back(make_pair(i, 2.0 / netNode.size()));
					netmap[i] = false;
					//					cout << "i=" << i << "     " << netNode[i].degree() << "     " << netNode[i].betweenness() << " " << k << endl;
				}
				else if (netmap[i] == true && netNode[i].degree() >= 2){
					double minb = 0;
					for (size_t j = 0; j < netNode.size(); j++){
						if (World[i][j]>0 && netNode[j].betweenness() > 0) {
							if (minb == 0 || minb > netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1))){
								minb = netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1));
							}
						}
					}
					if (minb != 0){
						btness.push_back(make_pair(i, minb));
						netmap[i] = false;
						//						cout << "i=" << i << "     " << netNode[i].degree() << "     " << netNode[i].betweenness() <<" "<<k<< endl;
					}
				}
			}
			for (size_t i = 0; i < btness.size(); i++)
				netNode[btness[i].first].betweenness(btness[i].second);
			btness.clear();
			k++;
		}
		vector< pair<int, double> > btness;
		for (size_t i = 0; i < netNode.size(); i++){
			if (netNode[i].degree()>2){
				double minb = netNode[i].betweenness();
				for (size_t j = 0; j < netNode.size(); j++){
					if (World[i][j]>0) {
						if (minb < netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1))){
							minb = netNode[j].betweenness() + 2.0*(netNode.size() - k) / (netNode.size()*(netNode.size() - 1));
						}
					}
				}
				if (minb>netNode[i].betweenness())
					btness.push_back(make_pair(i, minb));
			}
		}
		for (size_t i = 0; i < btness.size(); i++)
			netNode[btness[i].first].betweenness(btness[i].second);
		//		printNodeData();
	}
	void setVulnerability(double alph = 0){
		double maxb = netNode[0].betweenness(), minb = maxb;
		double maxf = netNode[0].flow(), minf = maxf;
		for (size_t i = 1; i < netNode.size(); i++){
			if (maxb < netNode[i].betweenness())
				maxb = netNode[i].betweenness();
			if (minb > netNode[i].betweenness())
				minb = netNode[i].betweenness();
			if (maxf < netNode[i].flow())
				maxf = netNode[i].flow();
			if (minf > netNode[i].flow())
				minf = netNode[i].flow();
		}
		for (size_t i = 0; i < netNode.size(); i++){
			netNode[i].vulnerability((netNode[i].betweenness() - minb)*(1 - alph) / (maxb - minb) + (netNode[i].flow() - minf)*alph / (maxf - minf));
		}
	}
public:
	NETWORK(){}
	~NETWORK(){}

private:
	string netName;
	vector<NODE> netNode;
	vector<LINE> netLine;
	
private:
	double netDegree;
	double netBetweenness;
};

class METRONETWORK :public NETWORK{
private:
	void readNodeData(void){
		ifstream datfile;
		string path = "D:\\Program\\C++\\MetroNetwork\\Data\\name_all.dat";
		datfile.open(path);
		int n;
		datfile >> n;
		while (n--){
			NODE node;
			int num, linenum, flow;
			datfile >> num >> flow >> linenum;
			vector<int> line(linenum, 0);
			for (int i = 0; i < linenum; i++){
				datfile >> line[i];
			}
			node.number(num);
			node.flow(flow);
			node.linenumber(line);
			this->insert(node);
		}
		datfile.close();
	}
	void readNodeLineData(void){
		ifstream datfile;
		string path = "D:\\Program\\C++\\MetroNetwork\\Data\\len_all.dat";
		datfile.open(path);
		for (size_t i = 0; i < this->nodeSize(); ++i){
			vector<double> w;
			for (size_t j = 0; j < this->nodeSize(); ++j){
				double num;
				datfile >> num;
				w.push_back(num);
				if (num>0){
					LINE x;
					x.linelen(num);
					vector<NODE> y;
					if (i <= j){
						y.push_back(NODE(i + 1));
						y.push_back(NODE(j + 1));
					}
					else{
						y.push_back(NODE(j + 1));
						y.push_back(NODE(i + 1));
					}
					x.linenode(y);
					insert(x);
				}
			}
			this->World.push_back(w);
		}
		datfile.close();
		for (size_t i = 0; i < this->nodeSize(); ++i)
			for (size_t j = 0; j < i; ++j)
				World[i][j] = World[j][i];
	}
public:
	void create(void){
		cout << "First Read The Data!" << endl;
		readNodeData();
		readNodeLineData();
		this->setDegree();
		this->setBetweenness();
		this->setVulnerability();
	}
};

class VIRTUTALNETWORK :public NETWORK{

};
#endif;