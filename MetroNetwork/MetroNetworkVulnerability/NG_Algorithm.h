#pragma once
#ifndef NG_ALGORITHM_H
#define NG_ALGORITHM_H
#include "Node.h"
#include "Algorithm.h"
#include <iostream>
#include <vector>
using namespace std;
class NG_Algorithm:public Algorithm{
private:
	NODE findFirstNode(vector<NODE>& noSelectNode){
		double maxb = 0;
		size_t num = 0;
		for (size_t i = 0; i < noSelectNode.size(); i++){
			if (maxb<noSelectNode[i].vulnerability() || maxb == 0){
				num = i;
				maxb = noSelectNode[i].vulnerability();
			}
		}
		NODE nde = noSelectNode[num];
		noSelectNode.erase(noSelectNode.begin() + num);
		return nde;
	}
	vector<NODE> findNeighbor(vector<NODE> aNode, vector<NODE> noSelectNode, vector<vector<double>> world){
		vector<NODE>neighbor;
		for (size_t i = 0; i < aNode.size(); ++i){
			for (size_t j = 0; j < noSelectNode.size(); ++j)
			if (world[aNode[i].number() - 1][noSelectNode[j].number() - 1]>0){
				size_t z = 0;
				for (; z < neighbor.size(); ++z){
					if (neighbor[z].number() == noSelectNode[j].number())
						break;
				}
				if (z == neighbor.size())
					neighbor.push_back(noSelectNode[j]);
			}
		}
//		cout << "neighbor size=" << neighbor.size() << endl;
//		cout << "neighbor=";
//		for (size_t i = 0; i < neighbor.size(); ++i)
//			cout << neighbor[i].number() << " ";
//		cout << endl;
		return neighbor;
	}
	double findQ(AREA a, NODE selectNode, vector<vector<double>> world, vector<NODE> netNode){
		vector<NODE> aNode = a.node();
		double Li = 0, Lm = 0;
		aNode.push_back(selectNode);
		for (size_t i = 0; i < aNode.size(); ++i){
			for (size_t j = 0; j < netNode.size(); ++j){
				if (world[aNode[i].number()-1][j]>0){
					if (a.isNode(netNode[j]))
						Li++;
					else
						Lm++;
				}
			}
		}
		return Li / (Li + Lm);
	}
public:
	vector<AREA> NG_Start(vector<vector<double>> world, vector<NODE> netNode){
		cout << "We will make NG Algorithm!" << endl;
		vector<AREA> ret;//输出脆弱区域集
		vector<NODE> noSelectNode(netNode);//识别节点是否读取
		int i = 0;
		vector<NODE> neighbor;//邻接节点集
		while (!noSelectNode.empty()){
			AREA a;//存放脆弱区域
			a.number(++i);
			a.insert(findFirstNode(noSelectNode));//首个脆弱节点
			neighbor.clear();
			double maxQ = 0;
			while (!noSelectNode.empty()){
				neighbor = findNeighbor(a.node(), noSelectNode, world);//寻找邻接节点集
				int select;
				double Q = 0;
				for (size_t i = 0; i < neighbor.size(); ++i){
					double Qk = findQ(a, netNode[neighbor[i].number() - 1], world, netNode);//计算Qk值
					if (Qk>Q){
						Q = Qk;
						select = i;
					}
				}
				if (Q >= maxQ){
					maxQ = Q;
					a.insert(neighbor[select]);
					for (size_t z = 0; z < noSelectNode.size(); ++z){
						if (noSelectNode[z].number() == neighbor[select].number()){
							noSelectNode.erase(noSelectNode.begin() + z);
							break;
						}
					}
				}
				else
					break;
			}
			a.q(maxQ);
//			cout << "Area node=";
//			for (size_t i = 0; i < a.nodeSize(); ++i)
//				cout << a.node()[i].number()<<" ";
//			cout << maxQ << endl;
			ret.push_back(a);
		}
		return ret;
	}

public:
	NG_Algorithm(){
		name("NG");
	}
	~NG_Algorithm(){}
private:
};
#endif